using Epic.Internals.Shared.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Xml;

namespace Epic.Internals.Shared.ClientScriptGeneration
{
	/// <summary>
	/// This abstract class serves as the base class for generating client scripts
	/// </summary>
	/// <typeparam name="TAttributeType">the type of attribute to look for</typeparam>
	[DefaultMember("test")]
	public abstract class ClientScriptGenerator<TAttributeType> where TAttributeType : ClientScriptExtractedAttribute
	{
		/// <summary>
        /// The default namespace to use for the generated the client script.  Generally something like:
        /// TripReimbursement.Shared.ServerEnums
        /// </summary>
        private string _defaultNamespace;

        /// <summary>
        /// Private backing list of assemblies we are looking for
        /// </summary>
        private List<Assembly> _assemblies;

        /// <summary>
        /// The stringbuilder content that is building the client script
        /// </summary>
        private StringBuilder _content;

        /// <summary>
        /// Keeps a cache of all the XML documents I find, keyed by the xml file name
        /// </summary>
        private Dictionary<string, XmlDocument> _documentCache;

        /// <summary>
        /// Gets the dictionary containing the TypeAttributePairs for each namespace
        /// </summary>
        internal IReadOnlyDictionary<string, List<TypeAttributePair<TAttributeType>>> NamespaceGroups { get; private set; }
        
        /// <summary>
        /// Creates a new Client Script generator for the given assemblies
        /// </summary>
        /// <param name="assemblies">The list of assemblies to search</param>
        /// <param name="defaultNamespace">Specify the default namespace for all enums. this parameter is required.
        ///     Example: "TripReimbursement.Shared.ServerEnums"</param>
		public ClientScriptGenerator(List<Assembly> assemblies, string defaultNamespace)
        {
            if (string.IsNullOrEmpty(defaultNamespace))
            {
                throw new ArgumentNullException("defaultNamespace must be specified.");
            }

            _defaultNamespace = defaultNamespace;
            _assemblies = assemblies;
        }

        /// <summary>
		/// Searches the assemblies for types with the <typeparamref name="TAttributeType"/> attribute and creates
        /// the namespace groups 
        /// </summary>
        private void CreateNamespaceGroups()
        {
            Dictionary<string, List<TypeAttributePair<TAttributeType>>> namespaceGroups = new Dictionary<string, List<TypeAttributePair<TAttributeType>>>();

            //Loop assemblies
            foreach (Assembly assembly in _assemblies)
            {
                //Get all the enum types
                List<Type> type = assembly.GetTypes().ToList();
                foreach (Type oneEnum in type)
                {
                    //Add them if they are marked for extraction
                    TAttributeType attr = oneEnum.GetCustomAttribute<TAttributeType>();
                    if (attr != null)
                    {
                        TypeAttributePair<TAttributeType> typeAttrPair = new TypeAttributePair<TAttributeType>(oneEnum, attr);

                        string nameSpace = !string.IsNullOrEmpty(attr.OverrideNamespace) ? attr.OverrideNamespace : _defaultNamespace;

                        if (!namespaceGroups.ContainsKey(nameSpace))
                        {
                            namespaceGroups.Add(nameSpace, new List<TypeAttributePair<TAttributeType>>());

                        }
                        namespaceGroups[nameSpace].Add(typeAttrPair);
                    }
                }
            }

            NamespaceGroups = namespaceGroups;
        }

        /// <summary>
        /// Generates and writes the client script to the destination file
        /// </summary>
        /// <param name="destinationFile">The filepath of the destination</param>
        public void WriteClientScript(string destinationFile)
        {
            _content = new StringBuilder();
            AddFormatLine(0, "//File Autogenerated by {0}.  DO NOT EDIT. \r\n", this.GetType().Name);

            //Namespace Groups will be 
            CreateNamespaceGroups();

            _documentCache = new Dictionary<string, XmlDocument>();
			Write();
            _documentCache = null;

            string fileContents = _content.ToString();
            File.WriteAllText(destinationFile, fileContents);
			AfterWrite(destinationFile);
        }


		/// <summary>
		/// This abstract method will describe how to write that were found to have <typeparamref name="TAttributeType"/>
		/// The derived class can use NamespaceGroups to write the client script
		/// </summary>
		protected abstract void Write();

		/// <summary>
		/// This method is run after the file is written
		/// </summary>
		/// <param name="filename"></param>
		protected virtual void AfterWrite(string filename)
		{

		}

        /// <summary>
        /// Adds a line exactly how it is passed into the function
        /// </summary>
        /// <param name="indent">The indent to add</param>
        /// <param name="val">The string value to add to the line</param>
        protected void AddLine(int indent, string val)
        {
            for (int i = 0; i < indent; i++)
            {
                _content.Append("    ");  //a "tab", but using spaces
            }
            _content.AppendLine(val);
        }

        /// <summary>
        /// Adds a line after running string.Format on it
        /// </summary>
        /// <param name="indent">The number of indents to add to the line</param>
        /// <param name="stringToFormat">The string to format</param>
        /// <param name="formatArgs">the arguments for the format</param>
        protected void AddFormatLine(int indent, string stringToFormat, params object[] formatArgs)
        {           
            string val = string.Format(stringToFormat, formatArgs);
            AddLine(indent, val);
        }

        /// <summary>
        /// Gets a description of the type/property to include in the client script.  
        /// </summary>
        /// <param name="type">The type That the member belongs to</param>
        /// <param name="member">Optional: the member info to look up (such as the property)</param>
        /// <returns>The description from the XML comments for that member</returns>
        protected string GetMemberDescription(Type type, MemberInfo member = null)
        {
            XmlDocument documentation = FindXmlDocumentation(type);
            if (documentation == null)
            {
                return "(No XML Documentation found.  Enable XML Documentation through the project properties >> Build >> Output section >> XML Documentation file)";
            }

            //Default type
            string prefix = "T";
            string fullName = type.FullName; 

            //and if a member is passed in, add that
            if (member != null)
            {
                if (member is PropertyInfo)
                {
                    prefix = "P";                    
                }
                else if (member is FieldInfo)  // enums, generally
                {
                    prefix = "F";
                }
                else
                {
                    return "No XML Documentation defined for the member type of " + member.GetType().Name;
                }
                fullName += "." + member.Name;
            }

            string path = string.Format("{0}:{1}", prefix, fullName);
            XmlNode xmlDocuOfProp = documentation.SelectSingleNode(
                "//member[starts-with(@name, '" + path + "')]");
            if (xmlDocuOfProp == null)
            {
                return "";  // some types are kind of complicated to find... so i just ignore them for now
            }
            XmlNode summaryNode = xmlDocuOfProp.SelectSingleNode("summary");

            if (summaryNode == null)
            {
                return "";  // I guess it doesn't have a summary?
            }
            string cleanStr = Regex.Replace(summaryNode.InnerXml, @"\s+", " ").Trim();

            return cleanStr;
        }
        
        /// <summary>
        /// Attempts to find the XML documentation file for the assembly this type belongs to so it can pull in the
        /// XML comments. It needs to use
        /// the xml documentation, which has to be enabled in the Project (Build >> Output Section >> XML Doc)
        /// http://stackoverflow.com/questions/15602606/programmatically-get-summary-comments-at-runtime
        /// 
        /// </summary>
        /// <param name="forType">The type to find the XML comments for</param>
        /// <returns>The XML comment document, if it exists</returns>
        private XmlDocument FindXmlDocumentation(Type forType)
        {
            string xmlName = forType.Assembly.FullName.Substring(0, forType.Assembly.FullName.IndexOf(",")) + ".xml";

            if (_documentCache.ContainsKey(xmlName))
            {
                return _documentCache[xmlName];
            }

            // Get the location of the assembly
            // Codebase is in the form "file:\\C...." or whatever.  We can't have that.
            Uri dllFolder = new Uri(Path.GetDirectoryName(forType.Assembly.CodeBase));

            string xmlDocPath = FileUtils.FindFirstFile(dllFolder.LocalPath, xmlName);

            XmlDocument documentation = null;
            if (!string.IsNullOrEmpty(xmlDocPath))
            {
                documentation = new XmlDocument();
                documentation.Load(xmlDocPath);
                _documentCache.Add(xmlName, documentation);
            }

            return documentation;
        }
	}

	/// <summary>
	/// Represents a paired Type-Attribute object where the given
	/// attribute was found on the given type
	/// </summary>
	/// <typeparam name="TAttributeType">The Attribute type</typeparam>
	public class TypeAttributePair<TAttributeType> where TAttributeType : Attribute
	{
		/// <summary>
		/// Gets the attribute found on the type
		/// </summary>
		public TAttributeType AttributeValue { get; private set; }

		/// <summary>
		/// Gets the type the attribute was targeting
		/// </summary>
		public Type TargetType { get; private set; }

		/// <summary>
		/// Creates a new Type Attribute Pair
		/// </summary>
		/// <param name="type">The target type of the attribute</param>
		/// <param name="attr">The attribute for this type</param>
		internal TypeAttributePair(Type type, TAttributeType attr)
		{
			AttributeValue = attr;
			TargetType = type;
		}
	}
}
