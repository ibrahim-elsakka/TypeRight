using Epic.Internals.Shared.ClientScriptGeneration;
using Epic.Internals.Shared.Enums;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Epic.Internals.Shared.ClientScriptGeneration
{
    /// <summary>
    /// this class is responsible for generating the javascript file that will
    /// be used for the javascript Enum file (for intellisense)
    /// </summary>
    public class JavascriptEnumGenerator : JavascriptGenerator<ClientScriptEnumAttribute>
    {

        /// <summary>
        /// Creates a new Enum generator for the given assemblies.  
        /// </summary>
        /// <param name="inAssemblies">the list of assemblies.  Not having to pass this
        ///     in would be nice, but otherwise I had a huge list of assemblies and types.  I anticipate
        ///     this isn't a huge deal as all of our enums will probably be in one assembly</param>
        /// <param name="defaultNamespace">Specify the default namespace for all enums. this parameter is required.
        ///     Example: "TripReimbursement.Shared.ServerEnums"</param>
        /// <param name="regNamespace">The function call needed to register the namespace.  It will get the parameters appended onto it.
        ///     This parameter is required
        ///     Example: "TripReimbursement.Shared.Namespace.regNamespace"</param>
        public JavascriptEnumGenerator(List<Assembly> inAssemblies, string defaultNamespace, string regNamespace)
            : base(inAssemblies, defaultNamespace, regNamespace)
        {

        }

        /// <summary>
        /// Processes the list of Type Attr pairs found containing the javascript enum attr.  It appends these
        /// enums to the output content string
        /// </summary>
        /// <param name="typesForNamespace">The list of Type Attr Pairs found</param>
        protected override void GenerateJavascriptForNamespace(List<TypeAttributePair<ClientScriptEnumAttribute>> typesForNamespace)
        {            

            //Then add each as members of that namespace
            foreach (TypeAttributePair<ClientScriptEnumAttribute> typeAttrPair in typesForNamespace)
            {
                AddEnum(typeAttrPair);
                AddLine(0, "");
            }            
        }


        /// <summary>
        /// Adds an enum (an entire list of enums, that is).
        /// </summary>
        /// <param name="typeAttrPair">The type attr pair to generate the enum list for</param>
        private void AddEnum(TypeAttributePair<ClientScriptEnumAttribute> typeAttrPair)
        {
            int indent = 1;
            Type type = typeAttrPair.TargetType;
            ClientScriptEnumAttribute attr = typeAttrPair.AttributeValue;
            AddLine(indent, "/// <field>");
            AddFormatLine(indent, "/// {0}", GetMemberDescription(typeAttrPair.TargetType));
            AddFormatLine(indent, "/// Autogenerated from {0}", typeAttrPair.TargetType.FullName);
            AddLine(indent, "/// </field>");
            AddFormatLine(indent, "{0}: {{", type.Name);  // double {{ for string.format

            Array enumVals = type.GetEnumValues();

            for (int i = 0; i < enumVals.Length; i++)
            {
                //I couldn't figure out how to get these two pieces
                //of information in one object, so i just cast them to both
                //The underlying type may just be dynamic (based on the Enum)
                int intVal = (int)enumVals.GetValue(i);
                Enum enumVal = enumVals.GetValue(i) as Enum;
                AddEnumField(enumVal, intVal);
            }
            AddLine(indent, "},");
        }

        /// <summary>
        /// Given an Enum field, it adds it to the generated javascript
        /// </summary>
        /// <param name="enumVal">the enum val object</param>
        /// <param name="intVal">the integer value of the enum</param>
        private void AddEnumField(Enum enumVal, int intVal)
        {
            int indent = 2;
            //Add the documentation for the enum
            AddFormatLine(indent, "/// <field>{0}</field>",
                            GetMemberDescription(enumVal.GetType(),
                                    enumVal.GetType().GetField(enumVal.ToString())));
            AddFormatLine(indent, "{0}: {{", enumVal.ToString());

            EnumDisplayNameAttribute attr = EnumUtils.GetEnumDispNameAttribute(enumVal);
            AddFormatLine(indent + 1, "id: {0},", intVal);
            AddFormatLine(indent + 1, "name: \"{0}\",", attr.DisplayName);
            AddFormatLine(indent + 1, "abbrev: \"{0}\",", attr.Abbreviation);

            string extraData = GetExtraData(enumVal);
            if (!string.IsNullOrEmpty(extraData))
            {
                AddLine(indent + 1, extraData);
            }

            AddLine(indent, "},");
        }

        /// <summary>
        /// Determines whether the enum has extra data and returns it if so
        /// </summary>
        /// <param name="enumVal">The enum value</param>
        /// <returns>Extra data if it exits</returns>
        private string GetExtraData(Enum enumVal)
        {
            FieldInfo enumInfo = enumVal.GetType().GetField(enumVal.ToString());
            JavascriptEnumFieldDataAttribute fieldData = enumInfo.GetCustomAttribute<JavascriptEnumFieldDataAttribute>();

            if (fieldData != null)
            {
                return string.Join(",", fieldData.ExtraData);
            }
            return "";
        }
    }
}
